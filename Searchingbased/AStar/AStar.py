import os
import sys
import numpy as np

sys.path.append(os.path.dirname(os.path.abspath(__file__)) +
                "/../../../shenlanmotionplanning/")

from Map.Discrete.gridmap import grid_map


def get_f_from_open_list(elem):
    return elem[3]


class AStar(grid_map):
    def __init__(self, width: int,
                 height: int,
                 x_grid: int,
                 y_grid: int,
                 image_name: str,
                 start: list,
                 terminal: list,
                 obs_number: int,
                 map_file):
        super(AStar, self).__init__(width, height, x_grid, y_grid, image_name, start, terminal, obs_number, map_file)
        self.open_list = np.atleast_2d()  # open list
        self.close_list = np.atleast_2d()  # close list
        self.visited = np.atleast_2d()  # visited
        self.path = []  # final path, generated by parent
        self.parent = dict()  # to link different nodes

        '''initialization'''
        g_start = 0.
        h_start = self.heuristic(self.start, heu_type='Dijkstra', tie_breaker=False)
        f_start = g_start + h_start
        self.open_list.append([list(self.start), g_start, h_start, f_start])
        self.open_list.sort(key=get_f_from_open_list)
        self.map_flag[self.start[0], self.start[1]] = 1
        self.parent[tuple(self.start)] = tuple(self.start)
        """initialization"""

    def heuristic(self, grid: np.ndarray, heu_type: str = 'Dijkstra', tie_breaker: bool = True) -> float:
        sub = np.abs(grid - self.terminal)
        h = 0.
        if heu_type == 'Dijkstra':
            pass
        elif heu_type == 'Euclidean':
            h = np.linalg.norm(sub, ord=2)
        elif heu_type == 'Manhattan':
            h = np.linalg.norm(sub, ord=1)
        elif heu_type == 'H-Infinite':
            h = np.linalg.norm(sub, ord=np.inf)
        elif heu_type == 'Diagonal':
            h = float(sub[0] + sub[1] + (np.sqrt(2) - 2) * min(sub[0], sub[1]))
        else:
            pass

        if tie_breaker:
            h = h * (1 + 1.0 / np.sqrt(self.x_grid ** 2 + self.y_grid ** 2))

        return h

    def update_cost(self, hyper_node1, node2, heuristic_type):
        """a new node to be expended"""
        g = hyper_node1[1] + np.sqrt((hyper_node1[0][0] - node2[0]) ** 2 + (hyper_node1[0][1] - node2[1]) ** 2)
        h = self.heuristic(np.array(node2), heu_type=heuristic_type, tie_breaker=False)
        f = g + h
        if self.map_flag[node2[0], node2[1]] == 0:  # a new node
            new = [node2, g, h, f]
            self.map_flag[node2[0], node2[1]] = 1
            # self.open_list.append(new)
            self.open_list.append(new)
            self.parent[tuple(node2)] = tuple(hyper_node1[0])
        elif self.map_flag[node2[0], node2[1]] == 1:  # already in open list
            open_list_set = [i[0] for i in self.open_list]
            index = open_list_set.index(node2)
            f_old = self.open_list[index][3]
            if f_old > f:  # update
                self.open_list[index][1] = g
                self.open_list[index][2] = h
                self.open_list[index][3] = f
                self.parent[tuple(node2)] = tuple(hyper_node1[0])
        else:
            pass

    def get_neighbors(self, node: np.ndarray):
        """
        :param node:    [[x, y], g, h, f]
        :return:
        """
        for i in [-1, 0, 1]:
            for j in [-1, 0, 1]:
                temp = [node[0][0] + i, node[0][1] + j]
                if min(temp) < 0 or temp[0] >= self.x_grid or temp[1] >= self.y_grid:
                    continue
                if self.is_occupied(list(temp)):
                    continue
                self.update_cost(hyper_node1=node, node2=temp, heuristic_type='Euclidean')
                '''Dijkstra Euclidean Manhattan H-Infinite Diagonal'''

    def astar_main(self) -> bool:
        """
        :brief:     A-Star search
        :return:
        """

        while len(self.open_list) > 0:
            '''choose a node from open list'''
            node = self.open_list.pop(0)  # get the node with the lowest f
            self.map_flag[node[0][0], node[0][1]] = -1  # add the node into close list
            self.visited.append(node[0])
            # self.path.append(node[0])                           # add the node to final path
            '''choose a node from open list'''

            '''find the neighbors of the node, and add them into open list'''
            self.get_neighbors(node)
            self.open_list.sort(key=get_f_from_open_list)
            '''find the neighbors of the node, and add them into open list'''

            if node[0][0] == self.terminal[0] and node[0][1] == self.terminal[1]:
                # self.path.append(node[0])
                print('Path finding finished!')
                # print('visited:', self.visited)
                return True
        print('No path find!')
        return False

    def path_find(self):
        self.path = [tuple(self.terminal)]
        s = tuple(self.terminal)
        while True:
            s = self.parent[s]
            self.path.append(s)
            if s == tuple(self.start):
                break
        print('Final path:', self.path)


if __name__ == '__main__':
    # astar = AStar(width=300,
    #               height=300,
    #               x_grid=5,
    #               y_grid=5,
    #               image_name='A-Star',
    #               start=[0, 0],
    #               terminal=[4, 4],
    #               obs_number=0)
    # astar = AStar(width=300,
    #               height=300,
    #               x_grid=3,
    #               y_grid=3,
    #               image_name='A-Star',
    #               start=[0, 0],
    #               terminal=[2, 2],
    #               obs_number=0)
    astar = AStar(width=500,
                  height=500,
                  x_grid=20,
                  y_grid=20,
                  image_name='A-Star',
                  start=[0, 0],
                  terminal=[19, 19],
                  obs_number=150,
                  map_file=None)
    if astar.astar_main():
        astar.path_find()
        astar.map_draw_visited(astar.visited)
        astar.map_draw_path(astar.path)
        astar.save_image('astar_1.jpg')
